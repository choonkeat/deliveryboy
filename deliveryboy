#!/usr/bin/env ruby
$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), "lib"))
require 'process/highlander/pid'
include Process::Highlander::PID # so there can only be one

require 'deliveryboy/loggable'
require 'deliveryboy/maildir'
require 'rubygems'
require 'tmail'
require 'net/smtp'
require 'ftools'
require 'yaml'

class Deliveryboy
  include Loggable

  def initialize(config)
    @inbox  = Inbox.new(config["inbox"])
    @outbox = Outbox.new(config["outbox"])
    @smtp_host = config["smtp"]["hostname"]
    @smtp_port = config["smtp"]["port"]
    @hostname  = config["hostname"]
  end

  def deliver(mail)
    mail.ready_to_send
    Net::SMTP.start(@smtp_host, @smtp_port, @hostname) do |smtp|
      smtp.send_message(
        mail.encoded,
        (mail['return-path'] && mail['return-path'].spec) || mail.from,
        mail.destinations
      )
    end
  # rescue Errno::ECONNREFUSED
  #   raise if smtp_host
  #   mail.destinations.each do |single_destination|
  #     deliver(mail, single_destination, single_destination.split('@').last, 25)
  #   end
  end

  def run
    trap("INT") { log "shutting down ..."; @inbox.terminated = @outbox.terminated = true; }
    log "Trapping SIGINT ..."
    threads = []
    # read all mails in inbox, and invoke callbacks
    threads << Thread.new do
      @inbox.run do |io|
        @inbox.handle(TMail::Mail.parse(io.read))
      end
    end
    # read all mails in outbox, and deliver them via smtp
    threads << Thread.new do
      @outbox.run do |io|
        mail = TMail::Mail.parse(io.read)
        @outbox.handle(mail)
        self.deliver(mail)
      end
    end
    log "#{threads.length} threads #{threads.inspect} running ..."
    threads.collect {|t| t.join; log "thread #{t.inspect} done" }
    log "#{threads.length} threads done"
  end

  # to prettify logging output
  class Outbox < Maildir; end
  class Inbox < Maildir; end
end

Deliveryboy.new(YAML.load(IO.read("#{__FILE__}.yml"))).run
